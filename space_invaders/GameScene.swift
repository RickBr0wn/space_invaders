//
//  GameScene.swift
//  space_invaders
//
//  Created by Rick Brown on 23/12/2020.
//

import SpriteKit
import GameplayKit

/// Create the game score globaly so it will be scoped to all pf the scenes
var gameScore: Int = 0

class GameScene: SKScene, SKPhysicsContactDelegate {
  /// Create the lives amount and set it initially to 3
  var livesNumber: Int = 3
  /// Create a SKLabelNode to carry the lives, using the custom font
  let livesLabel = SKLabelNode(fontNamed: "theboldfont")
  /// Create the level number and set it initially to 0
  var levelNumber: Int = 0
  /// Create a SKLabelNode to carry the score, using the custom font
  let scoreLabel = SKLabelNode(fontNamed: "theboldfont")
  /// Define a scaleAmount
  let scaleAmount: CGFloat = 1.2
  /// The players ship
  let player = SKSpriteNode(imageNamed: "playerShip")
  /// These actions are defined globally to prevent a lag/delay the first time these SKSpriteNodes are rendered
  /// Create the sound for the bullet
  let bulletSound = SKAction.playSoundFileNamed("shoot.wav", waitForCompletion: false)
  /// Create a the sound for the explosion
  let explosionSound = SKAction.playSoundFileNamed("explosion.wav", waitForCompletion: false)
  /// Create a label to start the game with
  let tapToStartLabel = SKLabelNode(fontNamed: "theboldfont")
  
  /// Game state machine
  enum gameState {
    case preGame
    case inGame
    case postGame
  }
  
  var currentGameState = gameState.preGame
  
  // MARK: PhysicsCategories
  /**
   This struct is used to make decisions when 2 or more physics bodies collide.
   
   SKSpriteNode.SKPhysicsBody:
   - .categoryBitMask can be used to set the item to its category
   - .collisionBitMask will be used to see which items this item can collide with
   - .contactTestBitMask will be used to see which items this item can collide with
   
   Note: These 3 methods all require UInt32 to be passed to them
   
   The order of this is important. In the didBegin(_ contact: ) function, we will be sorting them.
   */
  struct PhysicsCategories {
    static let None: UInt32 = 0 // 0
    static let Player: UInt32 = 0b1 // 1
    static let Bullet: UInt32 = 0b10 // 2
    static let Enemy: UInt32 = 0b100 // 4
  }
  
  /// Helper function to generate a random number
  func random(min: CGFloat, max: CGFloat) -> CGFloat {
    return CGFloat.random(in: min...max)
  }
  
  /// Create a rectangle to be used for the game area
  let gameArea: CGRect
  
  // MARK: Initializer
  /// Creates the playable area.
  /// Access the initializer, pass it the size
  override init(size: CGSize) {
    /// Calculate the aspect ratio
    let maxAspectRatio: CGFloat = 16.0 / 9.0
    /// Using the aspect ratio, calculate the width of the game area
    let playableWidth = size.height / maxAspectRatio
    /// Calculate the margins, to center the game area
    let margin = (size.width - playableWidth) / 2
    
    /// Create the game area using calculated dimensions
    gameArea = CGRect(x: margin, y: .zero, width: playableWidth, height: size.height)
    
    super.init(size: size)
  }
  
  /// This code was generated by xcode. Dont' panic! It is a fall back, in case there is no Decoder
  required init?(coder aDecoder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
  }
  
  // MARK: didMove(to view: )
  override func didMove(to view: SKView) {
    /// Reset the game score to zero
    gameScore = .zero
    /// Set the scene to look for contacts of physic bodies. For this to work the scene must be of type SKPhysicsContactDelegate
    self.physicsWorld.contactDelegate = self
    
    // MARK: Background
    /// Create the background
    let background = SKSpriteNode(imageNamed: "background")
    /// Calculate thre size of the background
    background.size = CGSize (width: frame.maxX, height: frame.maxY)
    /// Position the background in the center of the screen
    background.position = CGPoint(x: self.size.width / 2, y: self.size.height / 2)
    /// Position the background on the lowest z index
    background.zPosition = 0
    /// Add the background to the scene
    addChild(background)
    
    // MARK: Player
    /// Position the player ship on the scene
    player.position = CGPoint(x: self.size.width / 2, y: 0 - player.size.height)
    /// Adjust the scale of the player ship
    player.setScale(scaleAmount)
    /// Set the z index of the player ship
    player.zPosition = 2
    /// Add a physics body to the player
    player.physicsBody = SKPhysicsBody(rectangleOf: player.size)
    /// After setting the physics body, gravity will be applied to the player, this need to be removed for this game
    player.physicsBody!.affectedByGravity = false
    /// Assign the player categoryBitMask from the PhysicsCategories struct
    player.physicsBody!.categoryBitMask = PhysicsCategories.Player
    /// Prevent the player from colliding with anything
    player.physicsBody!.collisionBitMask = PhysicsCategories.None
    /// Allow the player to make contact with enemy
    player.physicsBody!.contactTestBitMask = PhysicsCategories.Enemy
    /// Add the player ship to the scene
    addChild(player)
    
    // MARK: Labels
    /// Set the score labels text
    scoreLabel.text = "Score: 0"
    /// Set the score labels font size
    scoreLabel.fontSize = 70
    /// Set the score labels color
    scoreLabel.fontColor = SKColor.white
    /// Align the score label to the left
    scoreLabel.horizontalAlignmentMode = SKLabelHorizontalAlignmentMode.left
    /// Set the score labels position off the top of the scene
    scoreLabel.position = CGPoint(x: self.size.width * 0.15, y: self.size.height + scoreLabel.frame.size.height)
    /// Set the score labels z position
    scoreLabel.zPosition = 100
    /// Add the score label to the scene
    self.addChild(scoreLabel)
    
    /// Set the lives label text
    livesLabel.text = "Lives: \(livesNumber)"
    /// Set the lives label font size
    livesLabel.fontSize = 70
    /// Set the lives label color
    livesLabel.fontColor = SKColor.white
    /// Align the lives label to the right
    livesLabel.horizontalAlignmentMode = SKLabelHorizontalAlignmentMode.right
    /// Set the lives label position off the top of the scene
    livesLabel.position = CGPoint(x: self.size.width * 0.85, y: self.size.height + livesLabel.frame.size.height)
    /// Set the lives label z position
    livesLabel.zPosition = 100
    /// Add the lives label to the scene
    self.addChild(livesLabel)
    
    /// Define an action to control moving the labels onto the screen
    let moveOnToTheScreenAction = SKAction.moveTo(y: self.size.height * 0.9, duration: 0.3)
    /// Run this action on both the score and lives labels
    scoreLabel.run(moveOnToTheScreenAction)
    livesLabel.run(moveOnToTheScreenAction)
    
    /// Define and style the start label 
    tapToStartLabel.text = "Tap to start"
    tapToStartLabel.fontSize = 100
    tapToStartLabel.fontColor = SKColor.white
    tapToStartLabel.zPosition = 1
    tapToStartLabel.position = CGPoint(x: self.size.width / 2, y: self.size.height / 2)
    tapToStartLabel.alpha = 0
    /// Add the start label to the scene
    self.addChild(tapToStartLabel)
    
    let fadeInAction = SKAction.fadeIn(withDuration: 0.3)
    tapToStartLabel.run(fadeInAction)
  }
  
  // MARK: loseOneLife
  func loseOneLife() {
    /// Decrement the lives number
    livesNumber -= 1
    /// Update the label text
    livesLabel.text = "Lives: \(livesNumber)"
    
    /// Introduce a visual animation to display when a life was lost
    /// Create a scale up action
    let scaleUp = SKAction.scale(to: 1.5, duration: 0.2)
    /// Create a scale down action
    let scaleDown = SKAction.scale(to: 1, duration: 0.2)
    /// Create a sequence of actions
    let scaleSequence = SKAction.sequence([scaleUp, scaleDown])
    /// Run the sequence
    livesLabel.run(scaleSequence)
    /// Check for zero lives, and run game over function
    if livesNumber == 0 {
      runGameOver()
    }
  }
  
  
  // MARK: addScore
  func addScore() {
    /// Increment the game score
    gameScore += 1
    /// Update the label text
    scoreLabel.text = "Score: \(gameScore)"
    
    /// Check to see if a new level should be started
    if gameScore == 10 || gameScore == 25 || gameScore == 50 || gameScore == 75 {
      startNewLevel()
    }
    
    /// Introduce a visual animation to display when a point is scored
    /// Create a scale up action
    let scaleUp = SKAction.scale(to: 1.5, duration: 0.2)
    /// Create a scale down action
    let scaleDown = SKAction.scale(to: 1, duration: 0.2)
    /// Create a sequence of actions
    let scaleSequence = SKAction.sequence([scaleUp, scaleDown])
    /// Run the sequence
    scoreLabel.run(scaleSequence)
  }
  
  // MARK: runGameOver
  func runGameOver() {
    /// Change the currentGameState to 'postGame' using the game state machine
    currentGameState = gameState.postGame
    /// Terminate all of the running actions in the scene
    self.removeAllActions()
    
    /// For every bullet on the screen (there maybe multiple) the action(s) it is running must also be stopped. To do this find all of the child nodes to the scene with the name of 'Bullet'
    self.enumerateChildNodes(withName: "Bullet") {
      /// Loop through the list of bullets
      bullet, stop in
      /// For each bullet, remove all actions
      bullet.removeAllActions()
    }
    
    /// Repeat the above process for the child node called 'Enemy'
    self.enumerateChildNodes(withName: "Enemy") {
      /// Loop through the list of enemies
      enemy, stop in
      /// For each enemy, remove all actions
      enemy.removeAllActions()
    }
    
    /// Run the changeScene function
    let changeSceneAction = SKAction.run(changeScene)
    /// Create a wait duration
    let waitToChangeScene = SKAction.wait(forDuration: 1)
    /// Create a sequence, from the previously computed actions
    let changeSceneSequence = SKAction.sequence([waitToChangeScene, changeSceneAction])
    /// Run the sequence on this scene
    self.run(changeSceneSequence)
  }
  
  // MARK: changeScene
  /// This function will change the scene
  func changeScene() {
    /// Create an instance of the gameOverScene, and set the size to the current game size
    let sceneToMoveTo = GameOverScene(size: self.size)
    /// Set the scale mode to the current game scene scale
    sceneToMoveTo.scaleMode = self.scaleMode
    /// Create a transition
    let transition = SKTransition.fade(withDuration: 0.5)
    /// Present the scene, with the computed transition
    self.view!.presentScene(sceneToMoveTo, transition: transition)
  }
  
  // MARK: didBegin(_ contact: )
  /// This runs when 2 physics bodies collide
  func didBegin(_ contact: SKPhysicsContact) {
    /**
     The 'contact' argument here, will include the 2 physic bodies that have collided.
     - contact.bodyA
     - contact.bodyB
     
     eg: contact.bodyA.categoryBitMask = x
     */
    var body1 = SKPhysicsBody()
    var body2 = SKPhysicsBody()
    
    /// Determine that the lowest PhysicsCategories value will be assigned to 'body1',  and the highest PhysicsCategories value to 'body2'
    if contact.bodyA.categoryBitMask < contact.bodyB.categoryBitMask {
      body1 = contact.bodyA
      body2 = contact.bodyB
    } else {
      body1 = contact.bodyB
      body2 = contact.bodyA
    }
    
    /// If the player has hit the enemy
    if body1.categoryBitMask == PhysicsCategories.Player && body2.categoryBitMask == PhysicsCategories.Enemy {
      /// Confirm there is a player, then spawn an explosion in the players position
      if body1.node != nil {
        spawnExplosion(spawnPosition: body1.node!.position)
      }
      /// Confirm there is a enemy, then spawn an explosion in the enemies position
      if body2.node != nil {
        spawnExplosion(spawnPosition: body2.node!.position)
      }
      /// Find the node associated with the player physic body and remove it from the scene
      body1.node?.removeFromParent()
      /// Find the node associated with the enemy physics body and remove it from the scene
      body2.node?.removeFromParent()
      /// Run the runGameOver function
      runGameOver()
    }
    
    /// If the bullet has hit the enemy, and confirm that the enemy hit, is actually on the screen
    if body1.categoryBitMask == PhysicsCategories.Bullet && body2.categoryBitMask == PhysicsCategories.Enemy && body2.node?.position.y ?? self.size.height + 1 < self.size.height {
      /// Increment the score
      addScore()
      /// Confirm there is a player, then spawn an explosion in the players position
      if body1.node != nil {
        spawnExplosion(spawnPosition: body1.node!.position)
      }
      /// Find the node associated with the body1(bullet) physic body and remove it from the scene (parent)
      body1.node?.removeFromParent()
      /// Find the node associated with the body2 (enemy) physic body and remove it from the scene (parent)
      body2.node?.removeFromParent()
    }
  }
  
  // MARK: spawnExplosion(spawnPosition: )
  func spawnExplosion(spawnPosition: CGPoint) {
    /// Create the SKSpriteNode from the image
    let explosion = SKSpriteNode(imageNamed: "explosion")
    /// Position the SKSpriteNode in the supplied position (CGPoint)
    explosion.position = spawnPosition
    /// Set the z position
    explosion.zPosition = 3
    /// Add the explosion to the scene
    self.addChild(explosion)
    /// Create a SKAction to animate the scale of the explosion
    let scaleIn = SKAction.scale(to: 1.0, duration: 0.1)
    /// Create a SKAction to animate fade out the explosion
    let fadeOut = SKAction.fadeOut(withDuration: 0.1)
    /// Create a SKAction to remove the explosion from the scene
    let delete = SKAction.removeFromParent()
    /// Create a sequence
    let explosionSequence = SKAction.sequence([explosionSound, scaleIn, fadeOut, delete])
    /// Run the sequence
    explosion.run(explosionSequence)
  }
  
  // MARK: fireBullet
  func fireBullet() {
    let bullet = SKSpriteNode(imageNamed: "bullet")
    /// Add a reference 'name' to the bullet. We can use this later with self.enumerateChildNodes (see runGameOver function
    bullet.name = "Bullet"
    /// Set the scale amount for the bullet
    bullet.setScale(scaleAmount)
    /// Set the position of the bullet, starting from the players current position
    bullet.position = player.position
    /// Place the bullet on the correct z position
    bullet.zPosition = 1
    /// Add a physics body to the bullet
    bullet.physicsBody = SKPhysicsBody(rectangleOf: bullet.size)
    /// After setting the physics body, gravity will be applied to the bullet, this need to be removed for this game
    bullet.physicsBody!.affectedByGravity = false
    /// Assign the bullet categoryBitMask from the PhysicsCategories struct
    bullet.physicsBody!.categoryBitMask = PhysicsCategories.Bullet
    /// Prevent the bullet from colliding with anything
    bullet.physicsBody!.collisionBitMask = PhysicsCategories.None
    /// Allow the bullet to make contact with the enemy
    bullet.physicsBody!.contactTestBitMask = PhysicsCategories.Enemy
    /// Add the bullet to the scene
    addChild(bullet)
    
    /// Create a SKAction and use the .moveTo method to move to a given location
    let moveBullet = SKAction.moveTo(y: self.size.height + bullet.size.height, duration: 1)
    /// Create a SKAction to remove the bullet from the scene
    let deleteBullet = SKAction.removeFromParent()
    /// Create a sequence from these actions
    let bulletSequence = SKAction.sequence([bulletSound, moveBullet, deleteBullet])
    /// Run the sequence
    bullet.run(bulletSequence)
  }
  
  // MARK: spawnEnemy
  func spawnEnemy() {
    /// Using the random helper function define a start and end position. This will make the enemies move diagonally
    let randomXStart = random(min: gameArea.minX, max: gameArea.maxX)
    let randomXEnd = random(min: gameArea.minX, max: gameArea.maxX)
    
    /// Generate start and end points for the enemies, using the random x coordinate positions
    let startPoint = CGPoint(x: randomXStart, y: self.size.height * 1.2)
    let endPoint = CGPoint(x: randomXEnd, y: -self.size.height * 0.2)
    
    /// Spawn the enemy in its start point, and animate it to the end postion
    let enemy = SKSpriteNode(imageNamed: "enemyShip")
    /// Set the enemies scale
    enemy.setScale(scaleAmount)
    /// Set the enemies position from the start point
    enemy.position = startPoint
    /// Add the enemy to the correct z position
    enemy.zPosition = 2
    /// Add a name to the enemy
    enemy.name = "Enemy"
    /// Add a physics body to the enemy
    enemy.physicsBody = SKPhysicsBody(rectangleOf: enemy.size)
    /// After setting the physics body, gravity will be applied to the enemy, this need to be removed for this game
    enemy.physicsBody!.affectedByGravity = false
    /// Assign the enemy categoryBitMask from the PhysicsCategories struct
    enemy.physicsBody!.categoryBitMask = PhysicsCategories.Enemy
    /// Prevent the enemy from colliding with anything
    enemy.physicsBody!.collisionBitMask = PhysicsCategories.None
    /// Allow the enemy to make contact with player and/or bullet
    enemy.physicsBody!.contactTestBitMask = PhysicsCategories.Player | PhysicsCategories.Bullet
    
    /// Add the enemy to the scene
    self.addChild(enemy)
    /// Create the SKActions to move from one point to another, and delete the player ship when it has finished moving
    let moveEnemy = SKAction.move(to: endPoint, duration: 1.5)
    /// Create a SKAction to remove an enemy from the scene
    let deleteEnemy = SKAction.removeFromParent()
    /// Create an action to handle the removal of the life, after the deleteEnemy action is run in the sequence
    let loseALife = SKAction.run(loseOneLife)
    /// Create a sequence
    let enemySequence = SKAction.sequence([moveEnemy, deleteEnemy, loseALife])
    
    /// If the current game state is 'inGame', run the sequence
    if currentGameState == gameState.inGame {
      enemy.run(enemySequence)
    }
    
    /// Rotate the enemy in the direction that it is travelling
    let deltaX = endPoint.x - startPoint.x
    let deltaY = endPoint.y - startPoint.y
    let amountToRotate = atan2(deltaY, deltaX)
    enemy.zRotation = amountToRotate
  }
  
  // MARK: startnewLevel
  func startNewLevel() {
    /// Increment the level number
    levelNumber += 1
    
    /// If the scene already has the key "spawningEnemies" then it is running
    /// This if block ensures there is no action already running before the next code block fires
    if self.action(forKey: "spawningEnemies") != nil {
      self.removeAction(forKey: "spawningEnemies")
    }
    
    /// Set up level duration
    var levelDuration = TimeInterval()
    
    /// Swith the level duration according to level number
    switch levelNumber {
    case 1:
      levelDuration = 1.2
    case 2:
      levelDuration = 1
    case 3:
      levelDuration = 0.8
    case 4:
      levelDuration = 0.5
    case 5:
      levelDuration = 0.2
    default:
      levelDuration = 1
      print("Cannot find level information")
    }
    
    /// Create a SKAction to spawn an an enemy
    let spawn = SKAction.run(spawnEnemy)
    /// Create a SKAction to delay the spawning of enemies
    let waitToSpawn = SKAction.wait(forDuration: levelDuration)
    /// Create a sequence of SKActions
    let spawnSequence = SKAction.sequence([waitToSpawn, spawn])
    /// Create a SKAction to continually loop through the sequence
    let spawnForever = SKAction.repeatForever(spawnSequence)
    /// Run the sequence
    self.run(spawnForever, withKey: "spawningEnemies")
  }
  
  // MARK: touchesBegan(_ touches: , with event: )
  override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
    /// If the game state is 'inGame', fire the bullet
    if currentGameState == gameState.inGame {
      fireBullet()
    }
  }
  
  // MARK: touchesMoved(_ touches: , with event: )
  override func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent?) {
    for touch: AnyObject in touches {
      /// Calculate the position of the touch
      let pointOfTouch = touch.location(in: self)
      /// Calculate the previous position of the touch
      let previousPointOfTouch = touch.previousLocation(in: self)
      /// Calculate the difference, this will be the amount that has been dragged (touch)
      let amountDragged = pointOfTouch.x - previousPointOfTouch.x
      
      /// If the game state is 'inGame', adjust the players position
      if currentGameState == gameState.inGame {
        player.position.x += amountDragged
      }
      
      /// Check for and prevent the ship moving out of the game area
      /// If the ship moves off the screen, bump it back the opposite direction
      if player.position.x > gameArea.maxX - (player.size.width / 2) {
        player.position.x = gameArea.maxX - (player.size.width / 2)
      }
      
      if player.position.x < gameArea.minX + (player.size.width / 2) {
        player.position.x = gameArea.minX + (player.size.width / 2)
      }
    }
  }
}
