//
//  GameScene.swift
//  space_invaders
//
//  Created by Rick Brown on 23/12/2020.
//

import SpriteKit
import GameplayKit

class GameScene: SKScene, SKPhysicsContactDelegate {
  /// Define a scaleAmount
  let scaleAmount: CGFloat = 1.2
  /// The players ship
  let player = SKSpriteNode(imageNamed: "playerShip")
  /// These actions are defined globally to prevent a lag/delay the first time these SKSpriteNodes are rendered
  /// Create the sound for the bullet
  let bulletSound = SKAction.playSoundFileNamed("shoot.wav", waitForCompletion: false)
  /// Create a the sound for the explosion
  let explosionSound = SKAction.playSoundFileNamed("explosion.wav", waitForCompletion: false)
  
  // MARK: PhysicsCategories
  /**
   This struct is used to make decisions when 2 or more physics bodies collide.
   
   SKSpriteNode.SKPhysicsBody:
   - .categoryBitMask can be used to set the item to its category
   - .collisionBitMask will be used to see which items this item can collide with
   - .contactTestBitMask will be used to see which items this item can collide with
   
   Note: These 3 methods all require UInt32 to be passed to them
   
   The order of this is important. In the didBegin(_ contact: ) function, we will be sorting them.
   */
  struct PhysicsCategories {
    static let None: UInt32 = 0 // 0
    static let Player: UInt32 = 0b1 // 1
    static let Bullet: UInt32 = 0b10 // 2
    static let Enemy: UInt32 = 0b100 // 4
  }
  
  /// Helper function to generate a random number
  func random(min: CGFloat, max: CGFloat) -> CGFloat {
    return CGFloat.random(in: min...max)
  }
  
  /// Create a rectangle to be used for the game area
  let gameArea: CGRect
  
  // MARK: Initializer
  /// Creates the playable area.
  /// Access the initializer, pass it the size
  override init(size: CGSize) {
    /// Calculate the aspect ratio
    let maxAspectRatio: CGFloat = 16.0 / 9.0
    /// Using the aspect ratio, calculate the width of the game area
    let playableWidth = size.height / maxAspectRatio
    /// Calculate the margins, to center the game area
    let margin = (size.width - playableWidth) / 2
    
    /// Create the game area using calculated dimensions
    gameArea = CGRect(x: margin, y: .zero, width: playableWidth, height: size.height)
    
    super.init(size: size)
  }
  
  /// This code was generated by xcode. Dont' panic! It is a fall back, in case there is no Decoder
  required init?(coder aDecoder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
  }
  
  // MARK: didMove(to view: )
  override func didMove(to view: SKView) {
    /// Set the scene to look for contacts of physic bodies. For this to work the scene must be of type SKPhysicsContactDelegate
    self.physicsWorld.contactDelegate = self
    
    // MARK: Background
    /// Create the background
    let background = SKSpriteNode(imageNamed: "background")
    /// Calculate thre size of the background
    background.size = CGSize (width: frame.maxX, height: frame.maxY)
    /// Position the background in the center of the screen
    background.position = CGPoint(x: self.size.width / 2, y: self.size.height / 2)
    /// Position the background on the lowest z index
    background.zPosition = 0
    /// Add the background to the scene
    addChild(background)
    
    // MARK: Player
    /// Position the player ship on the scene
    player.position = CGPoint(x: self.size.width / 2, y: self.size.height * 0.2)
    /// Adjust the scale of the player ship
    player.setScale(scaleAmount)
    /// Set the z index of the player ship
    player.zPosition = 2
    /// Add a physics body to the player
    player.physicsBody = SKPhysicsBody(rectangleOf: player.size)
    /// After setting the physics body, gravity will be applied to the player, this need to be removed for this game
    player.physicsBody!.affectedByGravity = false
    /// Assign the player categoryBitMask from the PhysicsCategories struct
    player.physicsBody!.categoryBitMask = PhysicsCategories.Player
    /// Prevent the player from colliding with anything
    player.physicsBody!.collisionBitMask = PhysicsCategories.None
    /// Allow the player to make contact with enemy
    player.physicsBody!.contactTestBitMask = PhysicsCategories.Enemy
    /// Add the player ship to the scene
    addChild(player)
    
    /// Start the new level
    startNewLevel()
  }
  
  // MARK: didBegin(_ contact: )
  /// This runs when 2 physics bodies collide
  func didBegin(_ contact: SKPhysicsContact) {
    /**
     The 'contact' argument here, will include the 2 physic bodies that have collided.
     - contact.bodyA
     - contact.bodyB
     
     eg: contact.bodyA.categoryBitMask = x
     */
    var body1 = SKPhysicsBody()
    var body2 = SKPhysicsBody()
    
    /// Determine that the lowest PhysicsCategories value will be assigned to 'body1',  and the highest PhysicsCategories value to 'body2'
    if contact.bodyA.categoryBitMask < contact.bodyB.categoryBitMask {
      body1 = contact.bodyA
      body2 = contact.bodyB
    } else {
      body1 = contact.bodyB
      body2 = contact.bodyA
    }
    
    /// If the player has hit the enemy
    if body1.categoryBitMask == PhysicsCategories.Player && body2.categoryBitMask == PhysicsCategories.Enemy {
      /// Confirm there is a player, then spawn an explosion in the players position
      if body1.node != nil {
        spawnExplosion(spawnPosition: body1.node!.position)
      }
      /// Confirm there is a enemy, then spawn an explosion in the enemies position
      if body2.node != nil {
        spawnExplosion(spawnPosition: body2.node!.position)
      }
      /// Find the node associated with the player physic body and remove it from the scene
      body1.node?.removeFromParent()
      /// Find the node associated with the enemy physics body and remove it from the scene
      body2.node?.removeFromParent()
    }
    
    /// If the bullet has hit the enemy, and confirm that the enemy hit, is actually on the screen
    if body1.categoryBitMask == PhysicsCategories.Bullet && body2.categoryBitMask == PhysicsCategories.Enemy && body2.node?.position.y ?? self.size.height + 1 < self.size.height {
      /// Confirm there is a player, then spawn an explosion in the players position
      if body1.node != nil {
        spawnExplosion(spawnPosition: body1.node!.position)
      }
      /// Find the node associated with the body1(bullet) physic body and remove it from the scene (parent)
      body1.node?.removeFromParent()
      /// Find the node associated with the body2 (enemy) physic body and remove it from the scene (parent)
      body2.node?.removeFromParent()
    }
  }
  
  // MARK: spawnExplosion(spawnPosition: )
  func spawnExplosion(spawnPosition: CGPoint) {
    /// Create the SKSpriteNode from the image
    let explosion = SKSpriteNode(imageNamed: "explosion")
    /// Position the SKSpriteNode in the supplied position (CGPoint)
    explosion.position = spawnPosition
    /// Set the z position
    explosion.zPosition = 3
    /// Add the explosion to the scene
    self.addChild(explosion)
    /// Create a SKAction to animate the scale of the explosion
    let scaleIn = SKAction.scale(to: 1.0, duration: 0.1)
    /// Create a SKAction to animate fade out the explosion
    let fadeOut = SKAction.fadeOut(withDuration: 0.1)
    /// Create a SKAction to remove the explosion from the scene
    let delete = SKAction.removeFromParent()
    /// Create a sequence
    let explosionSequence = SKAction.sequence([explosionSound, scaleIn, fadeOut, delete])
    /// Run the sequence
    explosion.run(explosionSequence)
  }
  
  // MARK: fireBullet
  func fireBullet() {
    let bullet = SKSpriteNode(imageNamed: "bullet")
    bullet.setScale(scaleAmount)
    bullet.position = player.position
    bullet.zPosition = 1
    /// Add a physics body to the bullet
    bullet.physicsBody = SKPhysicsBody(rectangleOf: bullet.size)
    /// After setting the physics body, gravity will be applied to the bullet, this need to be removed for this game
    bullet.physicsBody!.affectedByGravity = false
    /// Assign the bullet categoryBitMask from the PhysicsCategories struct
    bullet.physicsBody!.categoryBitMask = PhysicsCategories.Bullet
    /// Prevent the bullet from colliding with anything
    bullet.physicsBody!.collisionBitMask = PhysicsCategories.None
    /// Allow the bullet to make contact with the enemy
    bullet.physicsBody!.contactTestBitMask = PhysicsCategories.Enemy
    /// Add the bullet to the scene
    addChild(bullet)
    
    /// Create a SKAction and use the .moveTo method to move to a given location
    let moveBullet = SKAction.moveTo(y: self.size.height + bullet.size.height, duration: 1)
    /// Create a SKAction to remove the bullet from the scene
    let deleteBullet = SKAction.removeFromParent()
    /// Create a sequence from these actions
    let bulletSequence = SKAction.sequence([bulletSound, moveBullet, deleteBullet])
    /// Run the sequence
    bullet.run(bulletSequence)
  }
  
  // MARK: spawnEnemy
  func spawnEnemy() {
    /// Using the random helper function define a start and end position. This will make the enemies move diagonally
    let randomXStart = random(min: gameArea.minX, max: gameArea.maxX)
    let randomXEnd = random(min: gameArea.minX, max: gameArea.maxX)
    
    /// Generate start and end points for the enemies, using the random x coordinate positions
    let startPoint = CGPoint(x: randomXStart, y: self.size.height * 1.2)
    let endPoint = CGPoint(x: randomXEnd, y: -self.size.height * 0.2)
    
    /// Spawn the enemy in its start point, and animate it to the end postion
    let enemy = SKSpriteNode(imageNamed: "enemyShip")
    enemy.setScale(scaleAmount)
    enemy.position = startPoint
    enemy.zPosition = 2
    /// Add a physics body to the enemy
    enemy.physicsBody = SKPhysicsBody(rectangleOf: enemy.size)
    /// After setting the physics body, gravity will be applied to the enemy, this need to be removed for this game
    enemy.physicsBody!.affectedByGravity = false
    /// Assign the enemy categoryBitMask from the PhysicsCategories struct
    enemy.physicsBody!.categoryBitMask = PhysicsCategories.Enemy
    /// Prevent the enemy from colliding with anything
    enemy.physicsBody!.collisionBitMask = PhysicsCategories.None
    /// Allow the enemy to make contact with player and/or bullet
    enemy.physicsBody!.contactTestBitMask = PhysicsCategories.Player | PhysicsCategories.Bullet
    
    /// Add the enemy to the scene
    self.addChild(enemy)
    
    /// Create the SKActions to move from one point to another, and delete the player ship when it has finished moving
    let moveEnemy = SKAction.move(to: endPoint, duration: 1.5)
    let deleteEnemy = SKAction.removeFromParent()
    /// Create a sequence
    let enemySequence = SKAction.sequence([moveEnemy, deleteEnemy])
    /// Run the sequence
    enemy.run(enemySequence)
    /// Rotate the enemy in the direction that it is travelling
    let deltaX = endPoint.x - startPoint.x
    let deltaY = endPoint.y - startPoint.y
    let amountToRotate = atan2(deltaY, deltaX)
    enemy.zRotation = amountToRotate
  }
  
  // MARK: startnewLevel
  func startNewLevel() {
    let spawn = SKAction.run(spawnEnemy)
    let waitToSpawn = SKAction.wait(forDuration: 1)
    let spawnSequence = SKAction.sequence([spawn, waitToSpawn])
    let spawnForever = SKAction.repeatForever(spawnSequence)
    self.run(spawnForever)
  }
  
  // MARK: touchesBegan(_ touches: , with event: )
  override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
    fireBullet()
  }
  
  override func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent?) {
    for touch: AnyObject in touches {
      /// Calculate the position of the touch
      let pointOfTouch = touch.location(in: self)
      /// Calculate the previous position of the touch
      let previousPointOfTouch = touch.previousLocation(in: self)
      /// Calculate the difference, this will be the amount that has been dragged (touch)
      let amountDragged = pointOfTouch.x - previousPointOfTouch.x
      
      /// Adjust the players position
      player.position.x += amountDragged
      
      /// Check for and prevent the ship moving out of the game area
      /// If the ship moves off the screen, bump it back the opposite direction
      if player.position.x > gameArea.maxX - (player.size.width / 2) {
        player.position.x = gameArea.maxX - (player.size.width / 2)
      }
      
      if player.position.x < gameArea.minX + (player.size.width / 2) {
        player.position.x = gameArea.minX + (player.size.width / 2)
      }
    }
  }
}
