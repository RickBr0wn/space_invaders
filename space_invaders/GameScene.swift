//
//  GameScene.swift
//  space_invaders
//
//  Created by Rick Brown on 23/12/2020.
//

import SpriteKit
import GameplayKit

class GameScene: SKScene {
  /// Define a scaleAmount
  let scaleAmount: CGFloat = 1.2
  /// The players ship
  let player = SKSpriteNode(imageNamed: "playerShip")
  /// The sound for the bullet
  let bulletSound = SKAction.playSoundFileNamed("shoot.wav", waitForCompletion: false)
  
  /// Helper function to generate a random number
  func random(min: CGFloat, max: CGFloat) -> CGFloat {
    return CGFloat.random(in: min...max)
  }
  
  /// Create a rectangle to be used for the game area
  let gameArea: CGRect

  /// Creates the playable area.
  /// Access the initializer, pass it the size
  override init(size: CGSize) {
    /// Calculate the aspect ratio
    let maxAspectRatio: CGFloat = 16.0 / 9.0
    /// Using the aspect ration, calculate the width of the game area
    let playableWidth = size.height / maxAspectRatio
    /// Calculate the margins, to center the game area
    let margin = (size.width - playableWidth) / 2

    /// Create the game area using calculated dimensions
    gameArea = CGRect(x: margin, y: 0, width: playableWidth, height: size.height)

    super.init(size: size)
  }
  
  /// This code was generated by xcode. It is a fall back, in case there is no Decoder
  required init?(coder aDecoder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
  }
  
  override func didMove(to view: SKView) {
    /// Create the background
    let background = SKSpriteNode(imageNamed: "background")
    /// Calculate thre size of the background
    background.size = CGSize (width: frame.maxX, height: frame.maxY)
    /// Position the background in the center of the screen
    background.position = CGPoint(x: self.size.width / 2, y: self.size.height / 2)
    /// Position the background on the lowest z index
    background.zPosition = 0
    /// Add the background to the scene
    addChild(background)
    
    /// Position the player ship on the scene
    player.position = CGPoint(x: self.size.width / 2, y: self.size.height * 0.2)
    /// Adjust the scale of the player ship
    player.setScale(scaleAmount)
    /// Set the z index of the player ship
    player.zPosition = 2
    /// Add the player ship to the scene
    addChild(player)
    
    /// Start the new level
    startNewLevel()
  }
  
  func fireBullet() {
    let bullet = SKSpriteNode(imageNamed: "bullet")
    bullet.setScale(scaleAmount)
    bullet.position = player.position
    bullet.zPosition = 1
    addChild(bullet)
    
    let moveBullet = SKAction.moveTo(y: self.size.height + bullet.size.height, duration: 1)
    let deleteBullet = SKAction.removeFromParent()
    let bulletSequence = SKAction.sequence([bulletSound, moveBullet, deleteBullet])
    bullet.run(bulletSequence)
  }
  
  func spawnEnemy() {
    /// Using the random helper function define a start and end position. This will make the enemies move diagonally
    let randomXStart = random(min: gameArea.minX, max: gameArea.maxX)
    let randomXEnd = random(min: gameArea.minX, max: gameArea.maxX)
    
    /// Generate start and end points for the enemies, using the random x coordinate positions
    let startPoint = CGPoint(x: randomXStart, y: self.size.height * 1.2)
    let endPoint = CGPoint(x: randomXEnd, y: -self.size.height * 0.2)
    
    /// Spawn the enemy in its start point, and animate it to the end postion
    let enemy = SKSpriteNode(imageNamed: "enemyShip")
    enemy.setScale(scaleAmount)
    enemy.position = startPoint
    enemy.zPosition = 2
    
    /// Add the enemy to the scene
    self.addChild(enemy)
    
    /// Create the SKActions to move from one point to another, and delete the player ship when it has finished moving
    let moveEnemy = SKAction.move(to: endPoint, duration: 1.5)
    let deleteEnemy = SKAction.removeFromParent()
    /// Create a sequence
    let enemySequence = SKAction.sequence([moveEnemy, deleteEnemy])
    /// Run the sequence
    enemy.run(enemySequence)
    /// Rotate the enemy in the direction that it is travelling
    let deltaX = endPoint.x - startPoint.x
    let deltaY = endPoint.y - startPoint.y
    let amountToRotate = atan2(deltaY, deltaX)
    enemy.zRotation = amountToRotate
  }
  
  func startNewLevel() {
    let spawn = SKAction.run(spawnEnemy)
    let waitToSpawn = SKAction.wait(forDuration: 1)
    let spawnSequence = SKAction.sequence([spawn, waitToSpawn])
    let spawnForever = SKAction.repeatForever(spawnSequence)
    self.run(spawnForever)
  }
  
  override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
    fireBullet()
  }
  
  override func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent?) {
    for touch: AnyObject in touches {
      /// Calculate the position of the touch
      let pointOfTouch = touch.location(in: self)
      /// Calculate the previous position of the touch
      let previousPointOfTouch = touch.previousLocation(in: self)
      /// Calculate the difference, this will be the amount that has been dragged (touch)
      let amountDragged = pointOfTouch.x - previousPointOfTouch.x
      
      /// Adjust the players position
      player.position.x += amountDragged
      
      /// Check for and prevent the ship moving out of the game area
      /// If the ship moves off the screen, bump it back the opposite direction
      if player.position.x > gameArea.maxX - (player.size.width / 2) {
        player.position.x = gameArea.maxX - (player.size.width / 2)
      }
      
      if player.position.x < gameArea.minX + (player.size.width / 2) {
        player.position.x = gameArea.minX + (player.size.width / 2)
      }
    }
  }
}
